diff --git a/build/NodeJSAriesAskar.js b/build/NodeJSAriesAskar.js
index 4075090529d3fafb9b518be432a69806ed66d21a..08a84857c8c3c8cda35b892fc2f93d2ecafdf08f 100644
--- a/build/NodeJSAriesAskar.js
+++ b/build/NodeJSAriesAskar.js
@@ -164,7 +164,9 @@ class NodeJSAriesAskar {
         const errorCode = this.nativeAriesAskar.askar_entry_list_get_value(entryListHandle, index, ret);
         this.handleError(errorCode);
         const byteBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(byteBuffer));
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyAeadDecrypt(options) {
         const { aad, ciphertext, localKeyHandle, nonce, tag } = (0, ffi_1.serializeArguments)(options);
@@ -172,7 +174,9 @@ class NodeJSAriesAskar {
         const errorCode = this.nativeAriesAskar.askar_key_aead_decrypt(localKeyHandle, ciphertext, nonce, tag, aad, ret);
         this.handleError(errorCode);
         const byteBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(byteBuffer));
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyAeadEncrypt(options) {
         const { localKeyHandle, aad, nonce, message } = (0, ffi_1.serializeArguments)(options);
@@ -180,7 +184,9 @@ class NodeJSAriesAskar {
         const errorCode = this.nativeAriesAskar.askar_key_aead_encrypt(localKeyHandle, message, nonce, aad, ret);
         this.handleError(errorCode);
         const encryptedBuffer = handleReturnPointer(ret);
-        return (0, ffi_1.encryptedBufferStructToClass)(encryptedBuffer);
+        const encryptedBufferClass = (0, ffi_1.encryptedBufferStructToClass)(encryptedBuffer);
+        this.nativeAriesAskar.askar_buffer_free(encryptedBuffer.secretBuffer);
+        return encryptedBufferClass;
     }
     keyAeadGetPadding(options) {
         const { localKeyHandle, msgLen } = (0, ffi_1.serializeArguments)(options);
@@ -201,8 +207,10 @@ class NodeJSAriesAskar {
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_aead_random_nonce(localKeyHandle, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyConvert(options) {
         const { localKeyHandle, algorithm } = (0, ffi_1.serializeArguments)(options);
@@ -217,39 +225,49 @@ class NodeJSAriesAskar {
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_crypto_box(recipientKey, senderKey, message, nonce, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyCryptoBoxOpen(options) {
         const { nonce, message, senderKey, recipientKey } = (0, ffi_1.serializeArguments)(options);
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_crypto_box_open(recipientKey, senderKey, message, nonce, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyCryptoBoxRandomNonce() {
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_crypto_box_random_nonce(ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyCryptoBoxSeal(options) {
         const { message, localKeyHandle } = (0, ffi_1.serializeArguments)(options);
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_crypto_box_seal(localKeyHandle, message, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyCryptoBoxSealOpen(options) {
         const { ciphertext, localKeyHandle } = (0, ffi_1.serializeArguments)(options);
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_crypto_box_seal_open(localKeyHandle, ciphertext, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyDeriveEcdh1pu(options) {
         const { senderKey, recipientKey, algorithm, algId, apu, apv, ccTag, ephemeralKey, receive } = (0, ffi_1.serializeArguments)(options);
@@ -392,8 +410,10 @@ class NodeJSAriesAskar {
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_get_jwk_secret(localKeyHandle, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyGetJwkThumbprint(options) {
         const { localKeyHandle, algorithm } = (0, ffi_1.serializeArguments)(options);
@@ -407,24 +427,30 @@ class NodeJSAriesAskar {
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_get_public_bytes(localKeyHandle, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyGetSecretBytes(options) {
         const { localKeyHandle } = (0, ffi_1.serializeArguments)(options);
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_get_secret_bytes(localKeyHandle, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keySignMessage(options) {
         const { localKeyHandle, message, sigType } = (0, ffi_1.serializeArguments)(options);
         const ret = (0, ffi_1.allocateSecretBuffer)();
         const errorCode = this.nativeAriesAskar.askar_key_sign_message(localKeyHandle, message, sigType, ret);
         this.handleError(errorCode);
-        const secretBuffer = handleReturnPointer(ret);
-        return new Uint8Array((0, ffi_1.secretBufferToBuffer)(secretBuffer));
+        const byteBuffer = handleReturnPointer(ret);
+        const result = new Uint8Array(Buffer.from((0, ffi_1.secretBufferToBuffer)(byteBuffer)));
+        this.nativeAriesAskar.askar_buffer_free(byteBuffer);
+        return result;
     }
     keyUnwrapKey(options) {
         const { localKeyHandle, algorithm, ciphertext, nonce, tag } = (0, ffi_1.serializeArguments)(options);
@@ -447,7 +473,9 @@ class NodeJSAriesAskar {
         const errorCode = this.nativeAriesAskar.askar_key_wrap_key(localKeyHandle, other, nonce, ret);
         this.handleError(errorCode);
         const encryptedBuffer = handleReturnPointer(ret);
-        return (0, ffi_1.encryptedBufferStructToClass)(encryptedBuffer);
+        const encryptedBufferClass = (0, ffi_1.encryptedBufferStructToClass)(encryptedBuffer);
+        this.nativeAriesAskar.askar_buffer_free(encryptedBuffer.secretBuffer);
+        return encryptedBufferClass;
     }
     keyGetSupportedBackends() {
         const stringListHandlePtr = (0, ffi_1.allocateStringListHandle)();
